{"version":3,"file":"index.umd.js","sources":["../src/atomEffect.ts"],"sourcesContent":["import type { Atom, Getter, Setter } from 'jotai/vanilla'\nimport { atom } from 'jotai/vanilla'\n\ntype CleanupFn = () => void\ntype GetterWithPeek = Getter & { peek: Getter }\ntype SetterWithRecurse = Setter & { recurse: Setter }\n\nexport function atomEffect(\n  effectFn: (get: GetterWithPeek, set: SetterWithRecurse) => void | CleanupFn\n) {\n  const refAtom = atom(() => ({\n    mounted: false,\n    inProgress: 0,\n    promise: undefined as Promise<void> | undefined,\n    cleanup: undefined as CleanupFn | void,\n    fromCleanup: false,\n    recursing: false,\n    refresh: () => {},\n    refreshing: false,\n    get: (() => {}) as Getter,\n    set: (() => {}) as Setter,\n    pendingError: null as null | unknown,\n  }))\n\n  const refreshAtom = atom(0)\n\n  const initAtom = atom(null, (get, set, mounted: boolean) => {\n    const ref = get(refAtom)\n    ref.mounted = mounted\n    if (mounted) {\n      ref.get = get\n      ref.set = set\n      ref.refresh = () => {\n        try {\n          ref.refreshing = true\n          set(refreshAtom, (c) => c + 1)\n        } finally {\n          ref.refreshing = false\n        }\n      }\n      set(refreshAtom, (c) => c + 1)\n    } else {\n      throwIfPendingError(ref)\n      ref.cleanup?.()\n      ref.cleanup = undefined\n    }\n  })\n  initAtom.onMount = (init) => {\n    init(true)\n    return () => {\n      init(false)\n    }\n  }\n  const effectAtom = atom((get) => {\n    get(refreshAtom)\n    const ref = get(refAtom)\n    if (!ref.mounted) {\n      return ref.promise\n    }\n    if (ref.recursing) {\n      return ref.promise\n    }\n    if (ref.inProgress && !ref.refreshing) {\n      return ref.promise\n    }\n    throwIfPendingError(ref)\n    const currDeps = new Map<Atom<unknown>, unknown>()\n    const getter: GetterWithPeek = (a) => {\n      const value = get(a)\n      currDeps.set(a, value)\n      return value\n    }\n    getter.peek = (anAtom) => ref.get(anAtom)\n    const setter: SetterWithRecurse = (...args) => {\n      try {\n        ++ref.inProgress\n        return ref.set(...args)\n      } finally {\n        --ref.inProgress\n      }\n    }\n    setter.recurse = (anAtom, ...args) => {\n      if (ref.fromCleanup) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('cannot recurse inside cleanup')\n        }\n        return undefined as any\n      }\n      try {\n        ref.recursing = true\n        return ref.set(anAtom, ...args)\n      } finally {\n        ref.recursing = false\n        const depsChanged = Array.from(currDeps).some(([a, v]) => get(a) !== v)\n        if (depsChanged) {\n          ref.refresh()\n        }\n      }\n    }\n    ++ref.inProgress\n    const effector = () => {\n      try {\n        ref.refreshing = false\n        if (!ref.mounted) {\n          return\n        }\n        try {\n          ref.fromCleanup = true\n          ref.cleanup?.()\n        } finally {\n          ref.fromCleanup = false\n        }\n        ref.cleanup = effectFn(getter, setter)\n      } catch (error) {\n        ref.pendingError = error\n        ref.refresh()\n      } finally {\n        ref.promise = undefined\n        --ref.inProgress\n      }\n    }\n    return ref.refreshing\n      ? effector()\n      : (ref.promise = Promise.resolve().then(effector))\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    refAtom.debugPrivate = true\n    refreshAtom.debugPrivate = true\n    initAtom.debugPrivate = true\n    effectAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    get(initAtom)\n    get(effectAtom)\n  })\n}\n\nfunction throwIfPendingError(ref: { pendingError: null | unknown }) {\n  if (ref.pendingError !== null) {\n    const error = ref.pendingError\n    ref.pendingError = null\n    throw error\n  }\n}\n"],"names":["throwIfPendingError","ref","pendingError","error","effectFn","refAtom","atom","mounted","inProgress","promise","undefined","cleanup","fromCleanup","recursing","refresh","refreshing","get","set","refreshAtom","initAtom","c","onMount","init","effectAtom","currDeps","Map","getter","a","value","peek","anAtom","setter","apply","slice","call","arguments","recurse","process","env","NODE_ENV","console","warn","concat","Array","from","some","_ref","v","effector","Promise","resolve","then","debugPrivate"],"mappings":"0RA0IA,SAASA,EAAoBC,GAC3B,GAAyB,OAArBA,EAAIC,aAAuB,CAC7B,IAAMC,EAAQF,EAAIC,aAElB,MADAD,EAAIC,aAAe,KACbC,CACP,CACH,cAzIM,SACJC,GAEA,IAAMC,EAAUC,EAAAA,KAAK,iBAAO,CAC1BC,SAAS,EACTC,WAAY,EACZC,aAASC,EACTC,aAASD,EACTE,aAAa,EACbC,WAAW,EACXC,QAAS,WAAQ,EACjBC,YAAY,EACZC,IAAM,WAAmB,EACzBC,IAAM,WAAK,EACXf,aAAc,KACf,GAEKgB,EAAcZ,OAAK,GAEnBa,EAAWb,EAAAA,KAAK,KAAM,SAACU,EAAKC,EAAKV,GACrC,IAAMN,EAAMe,EAAIX,GAChBJ,EAAIM,QAAUA,EACVA,GACFN,EAAIe,IAAMA,EACVf,EAAIgB,IAAMA,EACVhB,EAAIa,QAAU,WACZ,IACEb,EAAIc,YAAa,EACjBE,EAAIC,EAAa,SAACE,GAAC,OAAKA,EAAI,CAAC,EAC9B,CAAA,QACCnB,EAAIc,YAAa,CAClB,CACH,EACAE,EAAIC,EAAa,SAACE,GAAM,OAAAA,EAAI,CAAC,KAE7BpB,EAAoBC,GACpBA,MAAAA,EAAIU,SAAJV,EAAIU,UACJV,EAAIU,aAAUD,EAElB,GACAS,EAASE,QAAU,SAACC,GAElB,OADAA,GAAK,GACE,WACLA,GAAK,EACP,CACF,EACA,IAAMC,EAAajB,EAAIA,KAAC,SAACU,GACvBA,EAAIE,GACJ,IAAMjB,EAAMe,EAAIX,GAChB,IAAKJ,EAAIM,QACP,OAAON,EAAIQ,QAEb,GAAIR,EAAIY,UACN,OAAOZ,EAAIQ,QAEb,GAAIR,EAAIO,aAAeP,EAAIc,WACzB,OAAOd,EAAIQ,QAEbT,EAAoBC,GACpB,IAAMuB,EAAW,IAAIC,IACfC,EAAyB,SAACC,GAC9B,IAAMC,EAAQZ,EAAIW,GAElB,OADAH,EAASP,IAAIU,EAAGC,GACTA,CACT,EACAF,EAAOG,KAAO,SAACC,GAAM,OAAK7B,EAAIe,IAAIc,EAAO,EACzC,IAAMC,EAA4B,WAChC,IAEE,QADE9B,EAAIO,WACCP,EAAIgB,IAAGe,MAAP/B,EAAG,GAAAgC,MAAAC,KAAAC,WACX,CAAA,UACGlC,EAAIO,UACP,CACH,EACAuB,EAAOK,QAAU,SAACN,GAChB,GAAI7B,EAAIW,YACuB,eAAzByB,QAAQC,IAAIC,UACdC,QAAQC,KAAK,sCAIjB,IAEE,OADAxC,EAAIY,WAAY,EACTZ,EAAIgB,IAAGe,MAAP/B,EAAG,CAAK6B,GAAMY,OAAAT,GAAAA,MAAAC,KAAAC,UAAS,IAC/B,CAAA,QACClC,EAAIY,WAAY,EACI8B,MAAMC,KAAKpB,GAAUqB,KAAK,SAAAC,GAAE,IAAGC,EAACD,EAAM,GAAA,OAAA9B,EAAT8B,QAAoBC,CAAC,IAEpE9C,EAAIa,SAEP,CACH,IACEb,EAAIO,WACN,IAAMwC,EAAW,WACf,IAEE,GADA/C,EAAIc,YAAa,GACZd,EAAIM,QACP,OAEF,IACEN,EAAIW,aAAc,QAClBX,EAAIU,SAAJV,EAAIU,SACL,CAAA,QACCV,EAAIW,aAAc,CACnB,CACDX,EAAIU,QAAUP,EAASsB,EAAQK,EAChC,CAAC,MAAO5B,GACPF,EAAIC,aAAeC,EACnBF,EAAIa,SACL,CAAA,QACCb,EAAIQ,aAAUC,IACZT,EAAIO,UACP,CACH,EACA,OAAOP,EAAIc,WACPiC,IACC/C,EAAIQ,QAAUwC,QAAQC,UAAUC,KAAKH,EAC5C,GAQA,MAP6B,eAAzBX,QAAQC,IAAIC,WACdlC,EAAQ+C,cAAe,EACvBlC,EAAYkC,cAAe,EAC3BjC,EAASiC,cAAe,EACxB7B,EAAW6B,cAAe,GAGrB9C,OAAK,SAACU,GACXA,EAAIG,GACJH,EAAIO,EACN,EACF"}