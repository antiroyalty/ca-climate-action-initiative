import{atom as r}from"jotai/vanilla";function e(e){const o=r(()=>({mounted:!1,inProgress:0,promise:void 0,cleanup:void 0,fromCleanup:!1,recursing:!1,refresh:()=>{},refreshing:!1,get:()=>{},set:()=>{},pendingError:null})),s=r(0),i=r(null,(r,e,i)=>{const t=r(o);t.mounted=i,i?(t.get=r,t.set=e,t.refresh=()=>{try{t.refreshing=!0,e(s,r=>r+1)}finally{t.refreshing=!1}},e(s,r=>r+1)):(n(t),null==t.cleanup||t.cleanup(),t.cleanup=void 0)});i.onMount=r=>(r(!0),()=>{r(!1)});const t=r(r=>{r(s);const i=r(o);if(!i.mounted)return i.promise;if(i.recursing)return i.promise;if(i.inProgress&&!i.refreshing)return i.promise;n(i);const t=new Map,u=e=>{const n=r(e);return t.set(e,n),n};u.peek=r=>i.get(r);const l=(...r)=>{try{return++i.inProgress,i.set(...r)}finally{--i.inProgress}};l.recurse=(e,...n)=>{if(i.fromCleanup)"production"!==process.env.NODE_ENV&&console.warn("cannot recurse inside cleanup");else try{return i.recursing=!0,i.set(e,...n)}finally{i.recursing=!1,Array.from(t).some(([e,n])=>r(e)!==n)&&i.refresh()}},++i.inProgress;const c=()=>{try{if(i.refreshing=!1,!i.mounted)return;try{i.fromCleanup=!0,null==i.cleanup||i.cleanup()}finally{i.fromCleanup=!1}i.cleanup=e(u,l)}catch(r){i.pendingError=r,i.refresh()}finally{i.promise=void 0,--i.inProgress}};return i.refreshing?c():i.promise=Promise.resolve().then(c)});return"production"!==process.env.NODE_ENV&&(o.debugPrivate=!0,s.debugPrivate=!0,i.debugPrivate=!0,t.debugPrivate=!0),r(r=>{r(i),r(t)})}function n(r){if(null!==r.pendingError){const e=r.pendingError;throw r.pendingError=null,e}}export{e as atomEffect};
//# sourceMappingURL=index.modern.mjs.map
