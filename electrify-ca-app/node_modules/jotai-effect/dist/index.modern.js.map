{"version":3,"file":"index.modern.mjs","sources":["../src/atomEffect.ts"],"sourcesContent":["import type { Atom, Getter, Setter } from 'jotai/vanilla'\nimport { atom } from 'jotai/vanilla'\n\ntype CleanupFn = () => void\ntype GetterWithPeek = Getter & { peek: Getter }\ntype SetterWithRecurse = Setter & { recurse: Setter }\n\nexport function atomEffect(\n  effectFn: (get: GetterWithPeek, set: SetterWithRecurse) => void | CleanupFn\n) {\n  const refAtom = atom(() => ({\n    mounted: false,\n    inProgress: 0,\n    promise: undefined as Promise<void> | undefined,\n    cleanup: undefined as CleanupFn | void,\n    fromCleanup: false,\n    recursing: false,\n    refresh: () => {},\n    refreshing: false,\n    get: (() => {}) as Getter,\n    set: (() => {}) as Setter,\n    pendingError: null as null | unknown,\n  }))\n\n  const refreshAtom = atom(0)\n\n  const initAtom = atom(null, (get, set, mounted: boolean) => {\n    const ref = get(refAtom)\n    ref.mounted = mounted\n    if (mounted) {\n      ref.get = get\n      ref.set = set\n      ref.refresh = () => {\n        try {\n          ref.refreshing = true\n          set(refreshAtom, (c) => c + 1)\n        } finally {\n          ref.refreshing = false\n        }\n      }\n      set(refreshAtom, (c) => c + 1)\n    } else {\n      throwIfPendingError(ref)\n      ref.cleanup?.()\n      ref.cleanup = undefined\n    }\n  })\n  initAtom.onMount = (init) => {\n    init(true)\n    return () => {\n      init(false)\n    }\n  }\n  const effectAtom = atom((get) => {\n    get(refreshAtom)\n    const ref = get(refAtom)\n    if (!ref.mounted) {\n      return ref.promise\n    }\n    if (ref.recursing) {\n      return ref.promise\n    }\n    if (ref.inProgress && !ref.refreshing) {\n      return ref.promise\n    }\n    throwIfPendingError(ref)\n    const currDeps = new Map<Atom<unknown>, unknown>()\n    const getter: GetterWithPeek = (a) => {\n      const value = get(a)\n      currDeps.set(a, value)\n      return value\n    }\n    getter.peek = (anAtom) => ref.get(anAtom)\n    const setter: SetterWithRecurse = (...args) => {\n      try {\n        ++ref.inProgress\n        return ref.set(...args)\n      } finally {\n        --ref.inProgress\n      }\n    }\n    setter.recurse = (anAtom, ...args) => {\n      if (ref.fromCleanup) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('cannot recurse inside cleanup')\n        }\n        return undefined as any\n      }\n      try {\n        ref.recursing = true\n        return ref.set(anAtom, ...args)\n      } finally {\n        ref.recursing = false\n        const depsChanged = Array.from(currDeps).some(([a, v]) => get(a) !== v)\n        if (depsChanged) {\n          ref.refresh()\n        }\n      }\n    }\n    ++ref.inProgress\n    const effector = () => {\n      try {\n        ref.refreshing = false\n        if (!ref.mounted) {\n          return\n        }\n        try {\n          ref.fromCleanup = true\n          ref.cleanup?.()\n        } finally {\n          ref.fromCleanup = false\n        }\n        ref.cleanup = effectFn(getter, setter)\n      } catch (error) {\n        ref.pendingError = error\n        ref.refresh()\n      } finally {\n        ref.promise = undefined\n        --ref.inProgress\n      }\n    }\n    return ref.refreshing\n      ? effector()\n      : (ref.promise = Promise.resolve().then(effector))\n  })\n  if (process.env.NODE_ENV !== 'production') {\n    refAtom.debugPrivate = true\n    refreshAtom.debugPrivate = true\n    initAtom.debugPrivate = true\n    effectAtom.debugPrivate = true\n  }\n\n  return atom((get) => {\n    get(initAtom)\n    get(effectAtom)\n  })\n}\n\nfunction throwIfPendingError(ref: { pendingError: null | unknown }) {\n  if (ref.pendingError !== null) {\n    const error = ref.pendingError\n    ref.pendingError = null\n    throw error\n  }\n}\n"],"names":["atomEffect","effectFn","refAtom","atom","mounted","inProgress","promise","undefined","cleanup","fromCleanup","recursing","refresh","refreshing","get","set","pendingError","refreshAtom","initAtom","ref","c","throwIfPendingError","onMount","init","effectAtom","currDeps","Map","getter","a","value","peek","anAtom","setter","args","recurse","process","env","NODE_ENV","console","warn","Array","from","some","v","effector","error","Promise","resolve","then","debugPrivate"],"mappings":"8CAOgBA,EACdC,GAEA,MAAMC,EAAUC,EAAK,MACnBC,SAAS,EACTC,WAAY,EACZC,aAASC,EACTC,aAASD,EACTE,aAAa,EACbC,WAAW,EACXC,QAASA,OACTC,YAAY,EACZC,IAAMA,OACNC,IAAMA,OACNC,aAAc,QAGVC,EAAcb,EAAK,GAEnBc,EAAWd,EAAK,KAAM,CAACU,EAAKC,EAAKV,KACrC,MAAMc,EAAML,EAAIX,GAChBgB,EAAId,QAAUA,EACVA,GACFc,EAAIL,IAAMA,EACVK,EAAIJ,IAAMA,EACVI,EAAIP,QAAU,KACZ,IACEO,EAAIN,YAAa,EACjBE,EAAIE,EAAcG,GAAMA,EAAI,EAC7B,CAAA,QACCD,EAAIN,YAAa,CAClB,GAEHE,EAAIE,EAAcG,GAAMA,EAAI,KAE5BC,EAAoBF,GACT,MAAXA,EAAIV,SAAJU,EAAIV,UACJU,EAAIV,aAAUD,EACf,GAEHU,EAASI,QAAWC,IAClBA,GAAK,GACE,KACLA,GAAK,KAGT,MAAMC,EAAapB,EAAMU,IACvBA,EAAIG,GACJ,MAAME,EAAML,EAAIX,GAChB,IAAKgB,EAAId,QACP,OAAOc,EAAIZ,QAEb,GAAIY,EAAIR,UACN,OAAOQ,EAAIZ,QAEb,GAAIY,EAAIb,aAAea,EAAIN,WACzB,OAAOM,EAAIZ,QAEbc,EAAoBF,GACpB,MAAMM,EAAW,IAAIC,IACfC,EAA0BC,IAC9B,MAAMC,EAAQf,EAAIc,GAElB,OADAH,EAASV,IAAIa,EAAGC,GACTA,GAETF,EAAOG,KAAQC,GAAWZ,EAAIL,IAAIiB,GAClC,MAAMC,EAA4BA,IAAIC,KACpC,IAEE,QADEd,EAAIb,WACCa,EAAIJ,OAAOkB,EACnB,CAAA,UACGd,EAAIb,UACP,GAEH0B,EAAOE,QAAU,CAACH,KAAWE,KAC3B,GAAId,EAAIT,YACuB,eAAzByB,QAAQC,IAAIC,UACdC,QAAQC,KAAK,sCAIjB,IAEE,OADApB,EAAIR,WAAY,EACTQ,EAAIJ,IAAIgB,KAAWE,EAC3B,CAAA,QACCd,EAAIR,WAAY,EACI6B,MAAMC,KAAKhB,GAAUiB,KAAK,EAAEd,EAAGe,KAAO7B,EAAIc,KAAOe,IAEnExB,EAAIP,SAEP,KAEDO,EAAIb,WACN,MAAMsC,EAAWA,KACf,IAEE,GADAzB,EAAIN,YAAa,GACZM,EAAId,QACP,OAEF,IACEc,EAAIT,aAAc,QAClBS,EAAIV,SAAJU,EAAIV,SACL,CAAA,QACCU,EAAIT,aAAc,CACnB,CACDS,EAAIV,QAAUP,EAASyB,EAAQK,EAChC,CAAC,MAAOa,GACP1B,EAAIH,aAAe6B,EACnB1B,EAAIP,SACL,CAAA,QACCO,EAAIZ,aAAUC,IACZW,EAAIb,UACP,GAEH,OAAOa,EAAIN,WACP+B,IACCzB,EAAIZ,QAAUuC,QAAQC,UAAUC,KAAKJ,EAAQ,GASpD,MAP6B,eAAzBT,QAAQC,IAAIC,WACdlC,EAAQ8C,cAAe,EACvBhC,EAAYgC,cAAe,EAC3B/B,EAAS+B,cAAe,EACxBzB,EAAWyB,cAAe,GAGrB7C,EAAMU,IACXA,EAAII,GACJJ,EAAIU,IAER,CAEA,SAASH,EAAoBF,GAC3B,GAAyB,OAArBA,EAAIH,aAAuB,CAC7B,MAAM6B,EAAQ1B,EAAIH,aAElB,MADAG,EAAIH,aAAe,KACb6B,CACP,CACH"}